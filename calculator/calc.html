<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BBD Day 1 - Calculator</title>
    <link href="css/style.css" rel="stylesheet">
</head>
<body>
    
<main class="container">
    <section class="calculator">

        <!-- Mode Label at top-left of the calculator -->
        <header id="modeLabel" class="mode-label">Basic</header>

        <!-- Display Screen -->
        <section class="display">
        <input type="text" name="display">
        <p id="ghostParen" class="ghost-paren">)</p>
        </section>


        <!-- Button rows (empty: will be filled by JS) -->
        <section id="row1" class="button-row"></section>
        <section id="row2" class="button-row"></section>
        <section id="row3" class="button-row"></section>
        <section id="row4" class="button-row"></section>
        <section id="row5" class="button-row"></section>
        <section id="row6" class="button-row"></section>

    </section>
</main>

<!-- JAVASCRIPT LOGIC -->
<script>

    // Reference to the calculator display
    const display = document.querySelector('input[name="display"]');
    display.value = "0";   // default state
    const ghostParenEl = document.getElementById("ghostParen"); // reference to ghost parenthesis

    // Long-press handling for AC/DE
    let clearDeleteTimeout = null;
    const LONG_PRESS_DURATION = 600; // ms

    // Flag to track if the last action was pressing "=" successfully
    let justEvaluated = false;

    /* 
       ----------------------------------------------------
       BUTTON LAYOUT (ROW STRUCTURE)
       ----------------------------------------------------
    */

    const buttonLayout = [
        // Row 1: %, (, ), AC/DE
        [
            { label: '%',   type: 'percent',     className: 'operators' },
            { label: '(',   type: 'parenOpen',   className: 'operators' },
            { label: ')',   type: 'parenClose',  className: 'operators' },
            { label: 'AC',  type: 'clearDelete', className: 'operators', id: 'clearDeleteBtn' }
        ],
        // Row 2: 1/x, x², √x, ÷
        [
            { label: '1/x',   type: 'reciprocal', className: 'operators' },
            { label: 'x²',    type: 'square',     className: 'operators' },
            { label: '√x',    type: 'sqrt',       className: 'operators' },
            { label: '/',     type: 'operator',   className: 'operators' }
        ],
        // Row 3: 7 8 9 x
        [
            { label: '7', type: 'number' },
            { label: '8', type: 'number' },
            { label: '9', type: 'number' },
            { label: 'x', type: 'operator', className: 'operators' }
        ],
        // Row 4: 4 5 6 -
        [
            { label: '4', type: 'number' },
            { label: '5', type: 'number' },
            { label: '6', type: 'number' },
            { label: '-', type: 'operator', className: 'operators' }
        ],
        // Row 5: 1 2 3 +
        [
            { label: '1', type: 'number' },
            { label: '2', type: 'number' },
            { label: '3', type: 'number' },
            { label: '+', type: 'operator', className: 'operators' }
        ],
        // Row 6: +/- 0 . =
        [
            { label: '+/-', type: 'sign', className: 'operators' },
            { label: '0',   type: 'number' },
            { label: '.',   type: 'dot',  className: 'operators' },
            { label: '=',   type: 'equal', className: 'equal' }
        ]
    ];

    /* 
       ----------------------------------------------------
       CREATE BUTTONS DYNAMICALLY
       ----------------------------------------------------
    */

    function createButtons() {
        buttonLayout.forEach((row, rowIndex) => {
            const rowSection = document.getElementById(`row${rowIndex + 1}`);
            row.forEach(config => {
                const btn = document.createElement('input');
                btn.type = 'button';
                btn.value = config.label;

                if (config.className) {
                    btn.classList.add(config.className);
                }

                if (config.id) {
                    btn.id = config.id;
                }

                // Attach event listeners based on type
                switch (config.type) {
                    case 'number':
                        btn.addEventListener('click', () => handleNumber(config.label));
                        break;
                    case 'operator':
                        btn.addEventListener('click', () => handleOperator(config.label));
                        break;
                    case 'dot':
                        btn.addEventListener('click', handleDot);
                        break;
                    case 'equal':
                        btn.addEventListener('click', calculateResult);
                        break;
                    case 'sign':
                        btn.addEventListener('click', toggleSign);
                        break;
                    case 'clearDelete':
                        // Long press = AC, short press = DE
                        btn.addEventListener('mousedown', startClearDelete);
                        btn.addEventListener('mouseup', endClearDelete);
                        btn.addEventListener('mouseleave', endClearDelete);
                        btn.addEventListener('touchstart', startClearDelete);
                        btn.addEventListener('touchend', endClearDelete);
                        break;
                    case 'percent':
                        btn.addEventListener('click', handlePercent);
                        break;
                    case 'parenOpen':
                        btn.addEventListener('click', () => handleParenthesis('('));
                        break;
                    case 'parenClose':
                        btn.addEventListener('click', () => handleParenthesis(')'));
                        break;
                    case 'reciprocal':
                        btn.addEventListener('click', handleReciprocal);
                        break;
                    case 'square':
                        btn.addEventListener('click', handleSquare);
                        break;
                    case 'sqrt':
                        btn.addEventListener('click', handleSqrt);
                        break;
                }

                rowSection.appendChild(btn);
            });
        });

        // Initialise AC/DE label correctly on load
        updateClearDeleteLabel();
    }


    /* 
       ----------------------------------------------------
       HELPER FUNCTIONS
       ---------------------------------------------------- 
    */

    function isAtMaxLength() {
        return display.value.length >= 12;
    }


    /* 
       ----------------------------------------------------
       AC / DE HYBRID BUTTON (SHORT vs LONG PRESS)
       ---------------------------------------------------- 
    */

    function updateClearDeleteLabel() {
        const btn = document.getElementById("clearDeleteBtn");
        if (!btn) return;

        if (display.value === "0") {
            btn.value = "AC";
        } else {
            btn.value = "DE";
        }
    }

    // Start timer when button is pressed down
    function startClearDelete(event) {
        event.preventDefault(); // prevent text selection / ghost clicks
        clearDeleteTimeout = setTimeout(() => {
            clearDisplayBtn();        // long press → AC
            clearDeleteTimeout = null;
        }, LONG_PRESS_DURATION);
    }

    // On release: if timer still pending, treat as DE (short press)
    function endClearDelete(event) {
        event.preventDefault();
        if (clearDeleteTimeout !== null) {
            clearTimeout(clearDeleteTimeout);
            clearDeleteTimeout = null;
            deleteLastBtn();          // short press → DE
        }
        // if null, AC already happened
    }

    /* 
       ----------------------------------------------------
       BASIC OPERATION FUNCTIONS 
       ----------------------------------------------------
    */

    function add(a, b) {
        return a + b; 
    }

    function subtract(a, b) {
        return a - b;
    }

    function multiply(a, b) {
        return a * b;
    }

    function divide(a, b) {
        // Handle divide-by-zero case
        if (b === 0) {
            return NaN; // we'll handle as "Error" 
        }
        return a / b;
    }

    /* 
       ----------------------------------------------------
       GHOST PARENTHESIS VISUAL AID
       ----------------------------------------------------
    */

    function countUnmatchedParens(expr) {
        let open = 0, close = 0;
        for (let ch of expr) {
            if (ch === '(') open++;
            if (ch === ')') close++;
        }
        return open - close;   // >0 means we still owe some ')'
    }

    function updateGhostParen() {
        if (!ghostParenEl) return;
        const expr = display.value;

        // No ghost when empty / default / error
        if (expr === "0" || expr === "" || expr === "Error") {
            ghostParenEl.style.display = "none";
            return;
        }

        const unmatched = countUnmatchedParens(expr);
        if (unmatched > 0) {
            ghostParenEl.style.display = "block";
        } else {
            ghostParenEl.style.display = "none";
        }
    }

    function canCloseParen(expr) {
        return countUnmatchedParens(expr) > 0;
    }


    /* 
       ----------------------------------------------------
       SCIENTIFIC FUNCTIONS
       (will implement these later)
       ----------------------------------------------------
    */

    // Handle when "%" is pressed
    function handlePercent() {
        let exp = display.value;

        // Convert last number to percentage
        const match = exp.match(/(\d+\.?\d*)$/);
        if (!match) return;

        const number = parseFloat(match[1]);
        const percent = number / 100;

        display.value = exp.replace(/(\d+\.?\d*)$/, percent);
        justEvaluated = false;
    }

    function handleReciprocal() {
        let exp = display.value;

        // Cannot operate on an error
        if (exp === "Error") return;

        // Find the last number in the expression
        const match = exp.match(/(-?\d+(\.\d+)?|\d+(\.\d+)?)(?=$)/);
        if (!match) return;

        const numberStr = match[0];
        const number = parseFloat(numberStr);

        // Division by zero → Error
        if (number === 0) {
            display.value = "Error";
            justEvaluated = false;
            updateClearDeleteLabel();
            updateGhostParen();
            return;
        }

        const result = 1 / number;

        // Replace the last number with the reciprocal
        display.value = exp.slice(0, -numberStr.length) + result;

        justEvaluated = false;
        updateClearDeleteLabel();
        updateGhostParen();
    }


    function handleSquare() {
        let exp = display.value;

        if (exp === "Error") return;

        // Find last number
        const match = exp.match(/(-?\d+(\.\d+)?|\d+(\.\d+)?)(?=$)/);
        if (!match) return;

        const numberStr = match[0];
        const number = parseFloat(numberStr);

        const result = number * number;

        display.value = exp.slice(0, -numberStr.length) + result;

        justEvaluated = false;
        updateClearDeleteLabel();
        updateGhostParen();
    }


    function handleSqrt() {
        let exp = display.value;

        if (exp === "Error") return;

        // Find last number
        const match = exp.match(/(-?\d+(\.\d+)?|\d+(\.\d+)?)(?=$)/);
        if (!match) return;

        const numberStr = match[0];
        const number = parseFloat(numberStr);

        // Negative inside √ → Error
        if (number < 0) {
            display.value = "Error";
            justEvaluated = false;
            updateClearDeleteLabel();
            updateGhostParen();
            return;
        }

        const result = Math.sqrt(number);

        display.value = exp.slice(0, -numberStr.length) + result;

        justEvaluated = false;
        updateClearDeleteLabel();
        updateGhostParen();
    }


    function toggleSign() {
        // Simple version: toggle sign if current display is a single number
        const current = display.value;

        if (current === "0" || current === "Error") {
            return;
        }

        // Only toggle if it's a plain number (no operators)
        if (!/^[+-]?\d*\.?\d+$/.test(current)) {
            return;
        }

        if (current.startsWith("-")) {
            display.value = current.slice(1);
        } else {
            display.value = "-" + current;
        }

        justEvaluated = false;
        updateClearDeleteLabel();
    }

    /* 
       ----------------------------------------------------
       BASIC HANDLER FUNCTIONS
       ----------------------------------------------------
    */

    // Handle when a number (0–9) is pressed
    function handleNumber(digit) {
        if (isAtMaxLength()) return;

        // If result was just shown OR display says "Error" → start fresh
        if (justEvaluated || display.value === "Error") {
            display.value = digit;
        }
        // If display is just "0", replace it
        else if (display.value === "0") {
            display.value = digit;
        }
        // Normal case: append number
        else {
            display.value += digit;
        }

        justEvaluated = false;
        updateClearDeleteLabel();
        updateGhostParen();
    }

    // Handle when an operator (+, -, x, /) is pressed
   function handleOperator(op) {
        if (isAtMaxLength()) return;

        const operators = ['+', '-', 'x', '/'];
        const current = display.value;
        const lastChar = current.slice(-1);

        // If initial state is "0", allow operator chaining
        if (current === "0") {
            display.value = "0" + op;
            justEvaluated = false;
            updateClearDeleteLabel();
            updateGhostParen();
            return;
        }

        // If display is Error: only allow "-" to start fresh negative number
        if (current === "Error") {
            if (op === "-") {
                display.value = "-";
                updateClearDeleteLabel();
                updateGhostParen();
            }
            return;
        }

        // ---------- 1) Chaining after "=" ----------
        if (justEvaluated) {
            display.value = current + op;
            justEvaluated = false;
            updateClearDeleteLabel();
            updateGhostParen();
            return;
        }

        // ---------- 2) Special toggle behaviour for "-" ----------
        if (op === "-") {

            // Case A: last character is "-" → toggle to "+"
            if (lastChar === "-") {
                display.value = current.slice(0, -1) + "+";
                updateClearDeleteLabel();
                updateGhostParen();
                return;
            }

            // Case B: last character is "+" → toggle to "-"
            if (lastChar === "+") {
                display.value = current.slice(0, -1) + "-";
                updateClearDeleteLabel();
                updateGhostParen();
                return;
            }
        }

        // ---------- 3) Replace last operator if it's +, -, x, / ----------
        if (operators.includes(lastChar)) {
            display.value = current.slice(0, -1) + op;
            justEvaluated = false;
            updateClearDeleteLabel();
            updateGhostParen();
            return;
        }

        // ---------- 4) Normal append ----------
        display.value += op;
        justEvaluated = false;
        updateClearDeleteLabel();
        updateGhostParen();
    }


    // Handle when "." is pressed
    function handleDot() {
        if (isAtMaxLength()) return;

        const current = display.value;

        // After equals or Error → start a fresh decimal number
        if (justEvaluated || current === "Error") {
            display.value = "0.";
            justEvaluated = false;
            updateClearDeleteLabel();
            return;
        }

        // If display is "0", turn into "0."
        if (current === "0") {
            display.value = "0.";
            justEvaluated = false;
            updateClearDeleteLabel();
            return;
        }

        // Otherwise append dot
        display.value += '.';
        justEvaluated = false;
        updateClearDeleteLabel();
    }

    // Clear (AC) behaviour
    function clearDisplayBtn() {
        display.value = "0";
        justEvaluated = false;
        updateClearDeleteLabel();
    }

    // Delete (DE) behaviour
    function deleteLastBtn() {
        let current = display.value;

        // If currently showing an error, just reset to 0
        if (current === "Error") {
            display.value = "0";
            justEvaluated = false;
            updateClearDeleteLabel();
            return;
        }

        // If only one character left, or already "0", reset to "0"
        if (current.length <= 1 || current === "0") {
            display.value = "0";
        } else {
            // Remove last character
            display.value = current.slice(0, -1);
        }

        justEvaluated = false;
        updateClearDeleteLabel();
    }

    // Handle when "(" or ")" is pressed
    function handleParenthesis(par) {
        const current = display.value;

        // Block parentheses when display is Error
        if (current === "Error") {
            return;
        }

        if (par === '(') {
            // Default 0 or just after result → start fresh with "("
            if (current === "0" || justEvaluated) {
                display.value = "(";
                justEvaluated = false;
                updateGhostParen();
                return;
            }

            const lastChar = current.slice(-1);

            // If previous char is a number, ".", "%", or ")", insert implicit multiply
            if (/[0-9.)%]/.test(lastChar)) {
                display.value = current + "x(";
            } else {
                display.value = current + "(";
            }

            justEvaluated = false;
            updateGhostParen();
            return;
        }

        // par === ')'
        // Don't allow ")" right after evaluation or if no "(" to close
        if (justEvaluated || !canCloseParen(current)) {
            return;
        }

        display.value = current + ")";
        justEvaluated = false;
        updateGhostParen();
    }



    /* 
       ----------------------------------------------------
       TOKENISER
       ----------------------------------------------------
    */
    function tokenize(expression) {
        const tokens = [];
        let currentNumber = '';

        const isOperator = (ch) => ['+', '-', 'x', '/'].includes(ch);

        for (let i = 0; i < expression.length; i++) {
            const ch = expression[i];

            if ((!isNaN(ch) && ch !== ' ') || ch === '.') {
                currentNumber += ch;
            }
            else if (ch === '%') {
                // finish the number and convert to percent
                if (currentNumber === '') return [];
                let num = parseFloat(currentNumber) / 100;
                tokens.push(num);
                currentNumber = '';
            }
            else if (ch === '(' || ch === ')') {
                // push any number before parentheses
                if (currentNumber !== '') {
                    tokens.push(parseFloat(currentNumber));
                    currentNumber = '';
                }
                tokens.push(ch);
            }
            else if (isOperator(ch)) {
                if (ch === '-' && (currentNumber === '' && (tokens.length === 0 || isOperator(tokens[tokens.length - 1]) || tokens[tokens.length - 1] === '('))) {
                    currentNumber += ch; // negative number
                } else {
                    if (currentNumber !== '') {
                        tokens.push(parseFloat(currentNumber));
                        currentNumber = '';
                    }
                    tokens.push(ch);
                }
            }
            else {
                return []; // invalid character
            }
        }

        if (currentNumber !== '') {
            tokens.push(parseFloat(currentNumber));
        }

        return tokens;
    }


    /* 
       ----------------------------------------------------
       EVALUATE WITH BODMAS
       ----------------------------------------------------
    */
    function evaluateTokens(tokens) {

        function evalRecursive(startIndex = 0) {
            const output = [];

            let i = startIndex;
            while (i < tokens.length) {
                const token = tokens[i];

                if (token === '(') {
                    // evaluate inside parentheses
                    const [value, newIndex] = evalRecursive(i + 1);
                    output.push(value);
                    i = newIndex;
                }
                else if (token === ')') {
                    break; // return to caller
                }
                else {
                    output.push(token);
                }

                i++;
            }

            // ---- FIRST PASS: × and ÷ ----
            let firstPass = [];
            firstPass.push(output[0]);

            for (let j = 1; j < output.length; j += 2) {
                const op = output[j];
                const nextNum = output[j + 1];

                if (op === 'x' || op === '/') {
                    const lastNum = firstPass.pop();
                    let intermediate =
                        op === 'x' ? multiply(lastNum, nextNum) :
                        divide(lastNum, nextNum);
                    firstPass.push(intermediate);
                } else {
                    firstPass.push(op, nextNum);
                }
            }

            // ---- SECOND PASS: + and - ----
            let result = firstPass[0];
            for (let j = 1; j < firstPass.length; j += 2) {
                const op = firstPass[j];
                const nextNum = firstPass[j + 1];

                result =
                    op === '+' ? add(result, nextNum) :
                    subtract(result, nextNum);
            }

            return [result, i];
        }

        return evalRecursive()[0];
    }


    /* 
       ----------------------------------------------------
       MAIN CALCULATOR FUNCTION
       ----------------------------------------------------
    */
    function calculateResult() {
        const expression = display.value;

        // Step 1: turn the string into number/operator tokens
        const tokens = tokenize(expression);

        // Invalid tokens → Error
        if (tokens.length === 0) {
            display.value = 'Error';
            justEvaluated = false;
            updateClearDeleteLabel();
            return;
        }

        // Step 2: evaluate with correct precedence
        const result = evaluateTokens(tokens);

        // Step 3: check for invalid numeric result
        if (isNaN(result)) {
            display.value = 'Error';
            justEvaluated = false;
        } else {
            display.value = result;
            justEvaluated = true; // mark that we just showed a final result
        }

        updateClearDeleteLabel();
    }

    // Build all buttons once DOM is ready
    createButtons();

</script>

</body>
</html>